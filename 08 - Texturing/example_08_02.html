<!doctype html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Cylinder with World Map Texture</title>
  <link rel="stylesheet" type="text/css" href="../styles/style.css">
  <script src="../scripts/webgl-utils.js"></script>
  <script src="../scripts/webgl-3d-math.js"></script>
</head>

<body>
  <canvas id="canvas" width="640" height="480"></canvas>

  <!-- Vertex shader -->
  <script id="vertex-shader" type="x-shader/x-vertex">
    attribute vec3 a_position;
    attribute vec3 a_normal;
    attribute vec2 a_texture_coords;

    uniform mat4 u_matrix;
    uniform mat4 u_n_matrix;

    uniform vec3  u_ambient_color;
    uniform vec3  u_diffuse_color;
    uniform vec3  u_specular_color;
    uniform vec3  u_lighting_direction;
    uniform float u_shininess;

    varying vec3 v_light_weight;
    varying vec2 v_texture_coords;

    void main() {
      v_texture_coords = a_texture_coords;

      vec4 position = u_matrix * vec4(a_position.xyz, 1.0);
      gl_Position = position;

      vec4 normal = u_n_matrix * vec4(a_normal, 0.0);
      vec3 lightDirection = -u_lighting_direction;

      float diffuseWeight = max(dot(normal.xyz, lightDirection), 0.0);

      vec3 reflectionDirection = reflect(lightDirection, normal.xyz);
      vec3 eyeDirection = normalize(-position.xyz);
      float specularWeight = max(dot(eyeDirection, reflectionDirection), 0.0);
      specularWeight = pow(specularWeight, u_shininess);

      v_light_weight = u_ambient_color +
        u_diffuse_color * diffuseWeight +
        u_specular_color * specularWeight;
    }
  </script>

  <!-- Fragment shader -->
  <script id="fragment-shader" type="x-shader/x-fragment">
    precision mediump float;
    uniform sampler2D u_sampler;

    varying vec3 v_light_weight;
    varying vec2 v_texture_coords;

    void main() {
      vec4 color =  texture2D(u_sampler, v_texture_coords.st);
      gl_FragColor = vec4(color.rgb * v_light_weight, color.a);
    }
  </script>

  <!-- Main program -->
  <script type="text/javascript">

    // Vertices position array
    var vertices = [];

    // Vertices normals array
    var normals = [];

    // Vertices texture coordinate array
    var textureCoords = []

    // Normals array
    var N = 16;
    var R = 0.5;
    var step = 2 * Math.PI / N;

    for (var i = 0; i < N; ++i) {
      var alpha = step * i;
      var beta = step * (i + 1);

      var x1 = R * Math.cos(alpha);
      var z1 = R * Math.sin(alpha);
      var x2 = R * Math.cos(beta);
      var z2 = R * Math.sin(beta);

      var nx1 = Math.cos(alpha);
      var nz1 = Math.sin(alpha);
      var nx2 = Math.cos(beta);
      var nz2 = Math.sin(beta);

      // Top face
      vertices.push(x2,   0.5,  z2);
      vertices.push(0.0,  0.5, 0.0);
      vertices.push(x1,   0.5,  z1);

      normals.push(0.0, 1.0, 0.0);
      normals.push(0.0, 1.0, 0.0);
      normals.push(0.0, 1.0, 0.0);

      textureCoords.push(i / N, 0.95);
      textureCoords.push((i + 0.5) / N, 1.0);
      textureCoords.push((i + 1) / N, 0.95);

      // Bottom face
      vertices.push(x1,  -0.5,  z1);
      vertices.push(0.0, -0.5, 0.0);
      vertices.push(x2,  -0.5,  z2);

      normals.push(0.0, -1.0, 0.0);
      normals.push(0.0, -1.0, 0.0);
      normals.push(0.0, -1.0, 0.0);

      textureCoords.push(i / N, 0.05);
      textureCoords.push((i + 0.5) / N, 0.0);
      textureCoords.push((i + 1) / N, 0.05);

      // Side face
      vertices.push(x2, -0.5, z2);
      vertices.push(x1,  0.5, z1);
      vertices.push(x1, -0.5, z1);

      vertices.push(x1,  0.5, z1);
      vertices.push(x2, -0.5, z2);
      vertices.push(x2,  0.5, z2);

      normals.push(nx2, 0.0, nz2);
      normals.push(nx1, 0.0, nz1);
      normals.push(nx1, 0.0, nz1);

      normals.push(nx1, 0.0, nz1);
      normals.push(nx2, 0.0, nz2);
      normals.push(nx2, 0.0, nz2);

      textureCoords.push((i + 1) / N, 0.05);
      textureCoords.push(i / N, 0.95);
      textureCoords.push(i / N, 0.05);

      textureCoords.push(i / N, 0.95);
      textureCoords.push((i + 1) / N, 0.05);
      textureCoords.push((i + 1) / N, 0.95);
    }

    // Return WebGL context
    function getGLContext(id) {
      var canvas = document.getElementById(id);
      var gl = canvas.getContext('webgl') ||
               canvas.getContext('experimental-webgl');
      return gl;
    }

    // Initialize shaders
    function initShaders(gl) {
      var program = createProgramFromScripts(gl, ['vertex-shader', 'fragment-shader']);
      gl.useProgram(program);
      return program;
    }

    // Initialize buffers
    function initBuffers(gl, program) {
      // get location of 'a_position' attrubute
      var positionLocation = gl.getAttribLocation(program, 'a_position');

      // Create vertices buffer
      var positionBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
      gl.enableVertexAttribArray(positionLocation);
      gl.vertexAttribPointer(positionLocation, 3, gl.FLOAT, gl.FALSE, 0, 0);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

      // get location of 'a_normal' attrubute
      var normalLocation = gl.getAttribLocation(program, 'a_normal');

      // Create normals buffer
      var normalBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
      gl.enableVertexAttribArray(normalLocation);
      gl.vertexAttribPointer(normalLocation, 3, gl.FLOAT, gl.FALSE, 0, 0);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normals), gl.STATIC_DRAW);

      // Get location of 'a_texture_coords' attribute
      var textureCoordsLocation = gl.getAttribLocation(program, 'a_texture_coords');

      // Create texture coordinates buffer
      var textureCoordsBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, textureCoordsBuffer);
      gl.enableVertexAttribArray(textureCoordsLocation);
      gl.vertexAttribPointer(textureCoordsLocation, 2, gl.FLOAT, gl.FALSE, 0, 0);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoords), gl.STATIC_DRAW);
    }

    // Initialize WebGL
    function initWebGL(gl) {
      var program = initShaders(gl);
      initBuffers(gl, program);
      gl.enable(gl.DEPTH_TEST);
      return program;
    }

    // Get WebGL context
    var gl = getGLContext('canvas');
    if (!gl)
      alert('WebGL is not supported by your browser');
    else { // WebGL is supported
      var program = initWebGL(gl);

      var start = null;

      function drawScene(timestamp) {
        if (!start) start = timestamp;
        var elapsedSeconds = (timestamp - start) / 1000.0;
        var alpha = Math.PI / 2 * elapsedSeconds;

        // Clear context (fill background with yelow color)
        gl.clearColor(1.0, 1.0, 1.0, 1.0);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        // Set transformation matrix
        var matrix = makeYRotation(alpha);
        matrix = matrixMultiply(matrix, makeXRotation(-Math.PI / 6));
        gl.uniformMatrix4fv(gl.getUniformLocation(program, 'u_matrix'), gl.FALSE, matrix);

        // Set normal matrix
        var normalMatrix = makeInverse(matrix);
        normalMatrix = makeTranspose(normalMatrix);
        gl.uniformMatrix4fv(gl.getUniformLocation(program, 'u_n_matrix'), gl.FALSE, normalMatrix);

        // Set lighting parameters
        gl.uniform3f(gl.getUniformLocation(program, 'u_lighting_direction'), 0.6, 0.0, 0.8);
        gl.uniform3f(gl.getUniformLocation(program, 'u_ambient_color'),  0.2, 0.2, 0.2);
        gl.uniform3f(gl.getUniformLocation(program, 'u_diffuse_color'),  0.6, 0.6, 0.6);
        gl.uniform3f(gl.getUniformLocation(program, 'u_specular_color'), 0.0, 0.0, 0.0);
        gl.uniform1f(gl.getUniformLocation(program, 'u_shininess'), 6.0);

        // Set texture
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.uniform1i(gl.getUniformLocation(program, 'u_sampler'), 0);

        // Draw triangles
        var nVertices  = vertices.length / 3;
        var nNormals   = normals.length / 3;
        var nTexCoords = textureCoords.length / 2;
        if (nVertices !== nNormals || nVertices !== nTexCoords) {
          alert('Number of vertices, normals & texture coordinates should match!');
        } else {
          gl.drawArrays(gl.TRIANGLES, 0, nVertices);
        }

        // Draw next frame
        requestAnimationFrame(drawScene);
      }

      var texture;
      function initTexture() {
        texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.bindTexture(gl.TEXTURE_2D, null);
      }

      var image = new Image();
      image.onload = function() {
        // Initialize texture
        initTexture();
        // Draw first frame
        requestAnimationFrame(drawScene);
      }
      image.src = '../textures/world-map.png'
    }

  </script>

</body>
</html>
